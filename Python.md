## 基础

- 逻辑运算符优先级：not > and > or

- 解包：`a, *b, c = [1, 2, 3, 4] -> b = [2, 3]`，先解包确定的位置，剩余的给带星号的变量

- 拷贝：

  - 浅拷贝：`b = a.copy()`，只能拷贝单层可变对象，如列表（乘法创建二维列表共用同一块内存地址，`b = 2 * [1, 2, 3]`）
  - 深拷贝：`from copy import deepcopy()`，`b = deepcopy(a)`，可以处理多层可变对象，如嵌套列表

  

## 书写格式

- 不同设置下tab可能表示不同数量的空格缩进



## 数据结构

- 变量：
  - 变量名记录对应的值在内存中的地址索引
    - `id(a)`获取地址，is判断两个变量的地址是否一致
    - 不可变对象：整数、浮点数、逻辑、字符串、元组，一旦创建内存中的内容不可修改（但元组中的可变对象，如列表可以修改）
    - 可变对象：列表、集合、字典，内存中的内容可以随时修改
    - 数值：[-5, 256]区间内常用数字是默认创建的，固定地址，任何时候出现地址都相同；其他数字每次出现都开辟新地址，即使数字的值一样，地址也不同
    - 字符串：每次开辟都固定地址（英文字母、数字、下划线），任何时候出现地址都相同
    - 容器：使用多级地址管理，在append和extend等自身修改操作，会影响拷贝前的变量；而加法等创建新变量的操作不会影响
  - 判断变量类型：
    - type：`x = type(a).__name__`
    - isinstance：`isinstance(a, int)`
  - 全局变量：在函数里引入`global x`，表示在该函数内可以对全局变量x进行更改
  
- 容器：
  - 列表：
    - x[:]创建新list
    - a + [4]或者a + [1, 2, 3 ]会创建新列表，使用append和extend在原列表中修改节约内存
    - x[8: 3: -1]表示以8为起始，4为结束，反向索引
  - 字典：
    - 重复的key，采用最新的一个来覆盖前面的
    - 更改键'a' -> 'b'：`d['b'] = d.pop('a')`
    - `f = {}.fromkeys(a, 0)`，根据列表a作为key生成字典（不会改变原字典本身，而是创建新字典），且默认值为0（避免把可变对象作为默认值）
    - 只有两列的二维列表a可以直接通过`b = dict(a)`转换为字典，`dict(zip(x, y))`
  - 集合：
    - 不能出现重复，且只能包含不可变元素
    - 交集：`c = a & b `，`a.union(b)`
    - 并集：`c = a | b`，`a.intersection(b)`
    - 差集：`c = a - b`，`a.difference(b)`，a里面有而b里面没有的元素
    - 子集：a是否为b的子集`a.issubset`，a是否为b的父集`a.issuperset`
  
- 数值：
  - 64位系统表示可以一次处理64个bit的数据，所以一般使用64个来bit（8个byte）表示一个数字（计算机最少1个byte用于存储一个数字，包含8个bit），python3中都是长整数
  - 判断是否为数字：`a.isnumeric()`
  - 四舍五入：
    - 银行家舍入法：round四舍五入，在5的位置奇数进位，偶数退位（但round受限于二进制，有时奇数遇到后续的5也会退位）
    - 显示小数：`format(x, '0.2f')`
  - //取余数：得到小于真实值的最大整数
    - 7 // 2 = 3
    - -7 // 2 = -4
  
- 布尔：
  - 布尔型变量True/False -> 1/0，是整数型变量的一个子类
  
- 字符：

  - ASCII字符编码表

    - ord('0') = 48，ord('A') = 65，ord('a') = 97
    - chr(49) = '1'，chr(10) + chr(13)表示换行 -> '\n'

  - 编码方案：

    - unicode（utf-8）兼容各种语言

    - GB18030兼容多种中文编码

    - chardet检测文本编码格式，也可以判断网页、数据库、文件等格式

    - ```python
      import chardet
      f = "XXX"
      with open(f, 'rb') as f: # rb中的b为binary，直接读取硬盘中的字节数值，获取s为byte类型
          s = f.read()
      d = chardet.detect(s)
      print(d)
      s1 = s.decode(d['encoding'])
      
      t = s1.encode('utf-8') # 按其他格式保存
      with open('XXX', 'wb') as f:
          f.write(t)
      ```

    - 编码：`b = '大家好'.encode('gb18030')`，解码：`b.decode('gb18030')`




## 文件操作

- r读取，w写入，a添加
- 文件夹下一层级所有文件名：`os.listdir(XXX)`
- 遍历文件夹中所有文件名：`os.walk(XXX)` -> [当前节点文件夹，[当前目录下子文件夹]，[当前目录下文件]]
- 文件重命名：`os.rename(原路径名，新路径名)`
- 操作结束后自动关闭文件：`with open(XXX, encoding='utf-8') as f:`



## 函数

- 传参：
  - 必选参数、可选参数（有默认值）、不定长参数（单星号）、不定长关键字参数（双星号）
    - 可变对象不能作为默认值，默认值只在程序运行之初的编译阶段被创建，并被反复调用，不会再后续进行初始化操作
  - 不定长参数：
    - `*x`表示将传入的多个无关键字参数自动组成一个tuple（也可以直接传一个tuple）
    - `**x`表示将传入的多个带关键字参数自动组成一个字典（也可以直接传一个字典）



## 类和对象

- 当调用一个对象的某个方法时，会在第一位自动添加一个代表该对象的参数，如实际运行`m1.add(self, 5, 3)`，`id(self) == id(m1)`

- 私有属性：通过在属性前面添加两个下划线来表示私有属性，`self.__x = 0`，在类内部变为`_m1__x`

- getter\setter模式：在类定义中，引入getter方法来读取私有属性，setter设置私有属性

- 多态：不同类中同一个方法名，功能不同，但可以统一调用

- 继承：

  - `class B(A)`，B类继承A类，可以重写或增加方法

  - 可以使用`b = B(); isinstance(b, A)`判断两个对象是否属于同一类（但继承同一父类的两个子类之间不相同）

  - 私有属性无法直接继承（继承时使用的是父类的名字，但子类中调用时使用的是子类的名字）

  - 属性是通过继承`__init__`方法实现的，该方法也可以重写覆盖

  - ```python
    class B(A):
        name = XXX # __init__()之外定义的属性是只属于该类的属性，不能被实例调用，即不能b.name
        def __init__(self, n, m, w):
            super().__init__(n, m) # 继承父类初始函数中的内容，不直接覆盖，并在此基础上进行扩展
            self.weibo = w
            
        def method(self):
            super().method() # 继承父类相同方法中的内容，而不是直接覆盖，并在此基础上进行扩展
            print(XXX)
    ```
    
  - 多继承：`class C(A, B)`，继承多个类别，如果A和B中有相同的方法名，则按从左到右的顺序优先调用
  
- `print()`，调用的是每个对象的`__repr__`方法，可以通过修改函数的repr方法来实现自定义打印功能

- `a.mro()`，得到自下而上所有的父类

- `help(a)`，得到类的简单文档

- `dir(a)`，得到类的所有属性方法

- `def func(): return`，空函数没有对象，为None



## 可迭代对象

- 容器：先开辟内存，再执行操作
- range对象，可以使用下标索引找到元素
- 迭代器：惰性策略，轮流出列，逐个访问，不立刻占用内存，而是保存计算规则
  - 时间换空间，每次调用都需要计算，`next(x)`获取下个值，只能被访问一次
  - 普通迭代器：`zip(x, y)`，多个参数以最短长度为基准
  - 生成器：圆括号列表生成式`(x for x in range(100000))`，或者使用yield关键字
- 特殊：
  - 字典的values()方法生成特殊的可迭代对象
  - Counter为特殊字典类型对象：`from collections import Counter`，可以使用加法、减法、交集、并集运算来进行统计，`c1 = Counter(a), c2=Counter(b), c = c1 + c2, c = c1 - c2`，其中减法运算只保留结果为正数的部分
  - chain将多个可迭代对象串起来：`from itertools import chain`，二维列表a打平到一维列表，`x = chain(*a)`



## 函数式编程

- 函数名是一个函数类型变量，指向函数内部代码的地址，可以赋值给一个变量`a = func`，而`a = func()`是执行该函数



## NumPy

- ndarray：n维数组，ndarray转列表`a.tolist()`



## pandas

- 面板数据分析工具
  - series：一维数组
  - dataframe：二维数组
- 读取文件：`a = pd.read_excel(文件路径, 工作簿名)`
- 写入数据：`a.to_excel(文件路径, 工作簿名)`，默认新建文件并写入，如果选择存在的文件路径，会覆盖原文件数据
- 定位数据：`a.iloc[x1: x2, y1: y2]`
- 转为ndarray：`b = a.values`



## 模块

- 安装：`pip install -i 镜像网址 模块名`
- `__name__`在该文件被独立允许时为`__main__`，被其他文件调用时为当前文件的名字（每个py程序都会被当作Module类来运行，其都有一个`__name__`属性表示自己的名字，`__file__`表示该程序的存储路径）



## 异常处理

```python
try: # 尝试运行如下操作
	XXX
except FileNotFoundError:# 可以执行多个except
	print('文件不存在！')
except Exception as e: 
	print('出现未知错误', e) # 查看错误类型
else: # 没出现异常则执行
	print('没出现异常')
finally: # 必须执行的操作
	print('程序执行结束')
```



## 正则表达式

```python
'''
	\X：元字符
	X：普通字符
	捕获结果之间互不重叠，且默认采用贪婪搜索，捕获最大长度字符
	
	
	\d：单个数字[0, 9]
	2\d\d-：以2起始的所有连续三位数字，且以-结尾, [200-, 299-]
	\d{8}：{}前面字符连续出现8次
	\d{m, n}：{}前面字符最少连续出现m次，最多n次，也可单边省略（m=0时，会捕获出空字符串）
	\d* = \d{0, }：字符不出现或出现任意次
	\d+ = \d{1, }：字符连续出现1次及以上
	\d? = \d{0,1}：字符出现0次或1次
	\d+\s*-\s*\d：捕获例如010 -  88223343
	
	
	\d：单个数字[0, 9]
	\D：表示非数字
	\s：空白字符，空格换行、缩进等
	\S：非空白字符
	\w：可以组成单词或汉字的字符，文字、字母、数字等（不包括标点）
	\W：非文字单词字符
	.：任意字符（是否包含换行符需要设置re.DOTALLS）
	
	
	[]：字符组，自定义准则，一个方括号代表一个字符，例如[abc]代表a或b或c，可用+?*表示多个
	[123456789] = [0-9] = \d
	[0-9a-zC-F]：找到所有的数字，小写字母，以及C到F之间的大写字母（因为-有特殊含义，所以如果想只表示-字符，需要放到字符组最前面，[-, :.。。（）]，其他字符无特殊含义）
	电话[是\s：（]*\d+[-\s）]+\d+：捕获，'电话： （010） -  66688777'，类型的字符串
	[^a-zA-Z]：找到所有非英文字母字符，只在第一个位置表特殊含义
	[^，]+：除逗号外的任意连续字符

	
	()：捕获组，只保留括号内部的内容，如果连续出现多个，如(ABC)+的结果中有ABCABC，则只保留最后一个ABC
	电话[是\s：（]*(\d+)[-\s）]+(\d+)：保留两个括号内的捕获组结果
	
	
	懒惰搜索：量词后面加上?，表示存在多种选项时，选择最短的
	《.*?》 = 《[^》]*》：捕获每个书名号字符串，但限制内部不存在书名号（懒惰搜索：就近匹配左右书名号）
	
	
	转义：特殊字符可以使用\进行转义
	r：python中使用r'XXX'，将所有反斜线转为双斜线不再表示转义字符（但单反斜线不能出现在字符串末尾）
	《[^》]*》\((.+?)\)：捕获书名后面括号内的作者国籍信息
	\b：表示一个文字字符与非文字字符之间的位置，但\b在python里面表示退格特殊字符，需要使用\\b
	\\b\w+\\b：所有非文字字符之间的内容
	
	
	(?:ABC)+：分组，()内的内容重复出现，但在python会被认为()捕获组，所以需要?:
	^：行首，需要选中多行模式，否则为整个文本开头
	$：行尾，需要选中多行模式，否则为整个文本结尾
	可以通过re.MULTILINE设置多行模式
	|：分支符号，表示或者，(com|net)
	
	
	(?=XX)：顺序肯定型环视，表示?=后面是什么内容，[.\d]+(?=%)得到以%结尾的数字
	(?!XX)：顺序否定型环视，表示?!后面不是什么内容，[.\d]+(?![.\d%])得到不以百分号、数字、点号结尾的数字
	(?<=XX)：逆序肯定型环视，表示?<=前面必须是什么内容，(?<=\.)\d+得到小数部分数字，(?<=\.)\d+(?=%)得到百分数里面的小数部分
	(?<!XX)：逆序否定型环视，表示?<!前面不是什么内容，(?<![.\d])\d+得到前面不是小数点或其他数字的数字，(?<![.\d])\d+(?<![.\d])得到所有的整数
	逆序环视中不能使用+*等量词，需要固定长度
	
	
	替换：先定位到需要替换的内容，将需要保留的部分做成捕获组，并对其编号（从左向右只看左括号），最后编写替换文本格式（可以使用编号来代替捕获组）
	\+(\d+)-(\d+) -> 国家号\1，地区号\2：+54-911-43992849 -> 国家号54，地区号911-43992849
	
	
	(\w)\1：反向引用，利用捕获组编号获取连续重复字符
	\b(\w)\w+\1\b：同意字母开头结尾的单词
'''


import re
s = 'XXX'
a = re.findall('\d+', s) # 找到所有的数字
# 得到带有捕获组的结果：
# 无捕获组返回完整匹配结果列表；
# 单个捕获组返回单个匹配结果列表；
# 多个捕获组返回多个匹配结果的元组列表
a = re.findall('电话[是\s：（]*(\d+)[-\s）]+(\d+)', s)
a = re.findall('《[^》]*》\((.+?)\)', s) # 捕获书名后面括号内的作者国籍信息
a = re.findall(r'(?:^\s*\w{5}，\s*\w{5}。\s*$\n)+', s, re.MULTILINE) # 捕获所有的五言古诗
a = re.findall(r'\d+(?:-\d+)+', s) # 捕获所有产品星号，23-4501-2311
a = re.findall(r'[\da-z_]+@([\da-z]+\.)+(com|net)', s) # 捕获所有电子邮件
a = re.sub(r'\+(\d+)-(\d+)', r'国家号\1，地区号\2', s) # 替换内容，原文本不会发生变化
a = re.search(f'\d+', s) # 返回文本中第一个满足条件子串，以及首尾索引，可以通过a.group(0)得到完整匹配结果，a.group(1)表示每个捕获组结果，a.groups()返回所有的捕获组结果元组
a = re.match(f'\d+', s) # 返回文本起始位置开始的第一个满足条件子串，以及首尾索引（首索引必须从0开始）
a = re.finditer(r'(\d+)-(\d+)-(\d+)', s) # findall和search的结合，返回可迭代对象，每个匹配结果以及首尾索引，也可以使用group()和groups()
p = re.compile(r'\d+'); a = p.findall(s) # 先编译正则表达式对象，方便后续使用，代替re


# 案例1：爬取信息
from urllib import request
import chardet
import re

res = request.urlopen('http://mobile.zol.com.cn/')
b = res.read()
d = chardet.detect(b) # 网页内部的charset标签记录了原始编码格式
s = b.decode('gbk') # d['encoding']

a = re.findall('<!--\s*手机图赏\s*-->.*?<!--end\s*手机图赏\s*-->', s, re.DOTALL) # 匹配区间内的内容，re.DOTALL为启动单行模式，此时.可以代表回车换行符
b = re.findall('<img.*?+src=“(.*?)”>', a[0]) # 得到所有的图片链接

for i in b:
    res = request.urlopen(i) # 根据链接获取图片
    c = res.read() # 使用字节流将图片读取到变量c中
    with open(f'XXX/{i[-10:]}', 'wb') as f:
        f.write(c)
        
# 案例2：

```





## 爬虫

- 启动浏览器窗口：`from urllib.request import urlopen`
- 获取网页反馈对象：`r = urlopen(XXX)`
- 获取网页内容：`c = r.read().decode('utf-8')`
- `<tr>与<\tr>之间`表示表格的每一行
- `<td>与<\td>之间`表示表格的每一列
- 使用BeautifulSoup：
  - `from bs4 import BeautifulSoup`
  - `bs_obj = BeautifulSoup(c, features='lxml')`
  - 获取表格：`t = bs_obj.find_all('table')`
  - 获取所有行：`all_tr = t.find_all('tr')`
